name: CI

on:
  push:
    branches: [main, develop, 'feat/**']
  pull_request:
    branches: [main, develop]

jobs:
  backend-tests:
    name: Backend Tests (${{ matrix.name }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Mock DB (macOS)"
            os: macos-latest
            use_mock: true
            test_cmd: "USE_MOCK_DB=true pnpm -F @verifd/backend test"
            
          - name: "SQLite (Linux)"
            os: ubuntu-latest
            use_mock: false
            test_cmd: "pnpm -F @verifd/backend test"
            needs_docker: true

    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: |
          if [ "${{ matrix.use_mock }}" = "true" ]; then
            # Skip native builds for mock tests
            pnpm install --ignore-scripts
          else
            pnpm install
          fi
          
      - name: Build shared packages
        run: pnpm -F @verifd/shared build
        
      - name: Start Docker services (Linux only)
        if: matrix.needs_docker
        run: |
          docker compose up -d
          sleep 5
          docker compose ps
          
      - name: Run database probe (Linux only)
        if: matrix.needs_docker
        run: |
          pnpm -F @verifd/backend run dev:probe || true
          
      - name: Run tests with coverage
        run: |
          if [ "${{ matrix.use_mock }}" = "true" ]; then
            USE_MOCK_DB=true pnpm -F @verifd/backend vitest run --coverage
          else
            pnpm -F @verifd/backend vitest run --coverage
          fi
        env:
          NODE_ENV: test
          DB_PATH: ${{ matrix.use_mock && ':memory:' || './test.db' }}
          
      - name: Upload coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.name }}
          path: apps/backend/coverage/lcov.info
          retention-days: 1
            
      - name: Stop Docker services
        if: always() && matrix.needs_docker
        run: docker compose down

  coverage-merge:
    name: Merge Coverage Reports
    needs: backend-tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: coverage-*
          path: coverage-reports
          
      - name: Install lcov-result-merger
        run: npm install -g lcov-result-merger
        
      - name: Merge coverage reports
        run: |
          mkdir -p merged-coverage
          if [ -d "coverage-reports" ] && find coverage-reports -name "lcov.info" 2>/dev/null | grep -q .; then
            find coverage-reports -name "lcov.info" -exec echo {} \; | xargs lcov-result-merger > merged-coverage/lcov.info
          else
            echo "No coverage reports found, creating empty report"
            echo "" > merged-coverage/lcov.info
          fi
          
      - name: Generate coverage summary
        run: |
          npm install -g lcov-summary
          lcov-summary merged-coverage/lcov.info || true
          
      - name: Upload merged coverage
        uses: actions/upload-artifact@v4
        with:
          name: merged-coverage
          path: merged-coverage/lcov.info
          
      - name: Generate coverage report
        id: coverage_report
        run: |
          # Calculate coverage percentage
          if [ -f "merged-coverage/lcov.info" ]; then
            LINES_HIT=$(grep -E "^LH:" merged-coverage/lcov.info | awk -F: '{sum+=$2} END {print sum}')
            LINES_TOTAL=$(grep -E "^LF:" merged-coverage/lcov.info | awk -F: '{sum+=$2} END {print sum}')
            FUNCTIONS_HIT=$(grep -E "^FNH:" merged-coverage/lcov.info | awk -F: '{sum+=$2} END {print sum}')
            FUNCTIONS_TOTAL=$(grep -E "^FNF:" merged-coverage/lcov.info | awk -F: '{sum+=$2} END {print sum}')
            
            if [ "$LINES_TOTAL" -gt 0 ]; then
              LINES_PCT=$((LINES_HIT * 100 / LINES_TOTAL))
            else
              LINES_PCT=0
            fi
            
            if [ "$FUNCTIONS_TOTAL" -gt 0 ]; then
              FUNCTIONS_PCT=$((FUNCTIONS_HIT * 100 / FUNCTIONS_TOTAL))
            else
              FUNCTIONS_PCT=0
            fi
            
            echo "lines_pct=$LINES_PCT" >> $GITHUB_OUTPUT
            echo "functions_pct=$FUNCTIONS_PCT" >> $GITHUB_OUTPUT
            echo "lines_hit=$LINES_HIT" >> $GITHUB_OUTPUT
            echo "lines_total=$LINES_TOTAL" >> $GITHUB_OUTPUT
          else
            echo "lines_pct=0" >> $GITHUB_OUTPUT
            echo "functions_pct=0" >> $GITHUB_OUTPUT
          fi
          
      - name: PR Coverage Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Get coverage data - same calculation as badges
            const linesPct = '${{ steps.coverage_report.outputs.lines_pct }}';
            const functionsPct = '${{ steps.coverage_report.outputs.functions_pct }}';
            const linesHit = '${{ steps.coverage_report.outputs.lines_hit }}';
            const linesTotal = '${{ steps.coverage_report.outputs.lines_total }}';
            
            // Get baseline from main branch (would fetch from API or artifact)
            const baselinePct = 70; // This should match badge baseline
            const delta = linesPct - baselinePct;
            const deltaStr = delta > 0 ? `+${delta}%` : `${delta}%`;
            
            // Determine emoji based on coverage - matches badge colors
            let emoji = '‚úÖ';
            let badgeColor = 'brightgreen';
            if (linesPct < 40) {
              emoji = 'üî¥';
              badgeColor = 'red';
            } else if (linesPct < 60) {
              emoji = 'üü°';
              badgeColor = 'yellow';
            } else if (linesPct < 80) {
              emoji = 'üü¢';
              badgeColor = 'green';
            }
            
            // Build comment body with delta
            const body = `## üìä Coverage Report ${emoji}
            
            | Metric | Coverage | Delta | Details |
            |--------|----------|-------|---------|
            | **Lines** | ${linesPct}% | ${deltaStr} | ${linesHit}/${linesTotal} |
            | **Functions** | ${functionsPct}% | - | - |
            
            ### üìÅ Artifacts
            - [Coverage Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - [Detailed LCOV](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts)
            
            ### üîç Coverage Thresholds
            - Lines: 40% (minimum)
            - Functions: 35% (minimum)
            - Branches: 30% (minimum)
            
            ### üìà Badge Preview
            \`![Coverage](https://img.shields.io/badge/coverage-${linesPct}%25-${badgeColor})\`
            
            ---
            *Generated by verifd CI ‚Ä¢ [View Workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})*`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Coverage Report')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  mobile-builds:
    name: Mobile Build & URL Safety
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          
      - uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --ignore-scripts
        
      - name: Android Release URL Gate
        run: |
          cd apps/android
          
          # Check release BuildConfig
          echo "Checking Android Release URL configuration..."
          
          # Look for the release configuration
          if grep -r "release" app/build.gradle | grep -q "buildConfigField"; then
            # Extract release URL from build.gradle
            RELEASE_URL=$(grep -A5 "release" app/build.gradle | grep "BASE_URL" | sed 's/.*"\(https:[^"\\]*\).*/\1/' | head -1 || echo "")
            
            if [ "$RELEASE_URL" != "https://api.verifd.com" ]; then
              echo "‚ùå ERROR: Android Release URL is not https://api.verifd.com"
              echo "Found: $RELEASE_URL"
              exit 1
            fi
            echo "‚úÖ Android Release URL correctly set to https://api.verifd.com"
          fi
          
          # Run unit tests
          ./gradlew testReleaseUnitTest || true
          
      - name: iOS Release URL Gate
        run: |
          cd apps/ios
          
          echo "Checking iOS Release URL configuration..."
          
          # Check Info.plist for production API URL
          if grep -q "https://api.verifd.com" verifd/Info.plist; then
            echo "‚úÖ iOS Release URL correctly set to https://api.verifd.com"
          else
            echo "‚ö†Ô∏è iOS Info.plist not found or URL not configured"
          fi

  # REMOVED DUPLICATE JOBS - Using matrix strategy in backend-tests job above
  # The backend-tests job with matrix strategy handles both SQLite and Mock DB tests
  
  # Merge coverage reports from matrix jobs
  merge-coverage:
    name: Merge Coverage Reports  
    runs-on: ubuntu-latest
    needs: [backend-tests]
    if: always()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install lcov-result-merger
        run: npm install -g lcov-result-merger

      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: coverage-*
          path: coverage-reports

      - name: List coverage files
        run: |
          ls -la coverage-reports/ || echo "No coverage reports found"
          find coverage-reports -name "lcov.info" || echo "No lcov.info files found"

      - name: Merge coverage reports
        run: |
          mkdir -p merged-coverage
          if find coverage-reports -name "lcov.info" 2>/dev/null | grep -q .; then
            find coverage-reports -name "lcov.info" -exec echo {} \; | xargs lcov-result-merger > merged-coverage/lcov.info
          else
            echo "No coverage reports to merge"
            echo "# No coverage data" > merged-coverage/lcov.info
          fi

      - name: Generate coverage report
        id: coverage_report
        run: |
          if [ -f merged-coverage/lcov.info ] && [ -s merged-coverage/lcov.info ]; then
            # Parse coverage data
            LINES_HIT=$(grep -E "^DA:" merged-coverage/lcov.info | cut -d',' -f2 | awk '$1>0' | wc -l || echo "0")
            LINES_TOTAL=$(grep -E "^DA:" merged-coverage/lcov.info | wc -l || echo "0")
            
            if [ "$LINES_TOTAL" -gt 0 ]; then
              LINES_PCT=$(awk "BEGIN {printf \"%.1f\", ($LINES_HIT/$LINES_TOTAL)*100}")
            else
              LINES_PCT="0"
            fi
            
            FUNCTIONS_HIT=$(grep -E "^FNDA:" merged-coverage/lcov.info | cut -d',' -f1 | cut -d':' -f2 | awk '$1>0' | wc -l || echo "0")
            FUNCTIONS_TOTAL=$(grep -E "^FN:" merged-coverage/lcov.info | wc -l || echo "0")
            
            if [ "$FUNCTIONS_TOTAL" -gt 0 ]; then
              FUNCTIONS_PCT=$(awk "BEGIN {printf \"%.1f\", ($FUNCTIONS_HIT/$FUNCTIONS_TOTAL)*100}")
            else
              FUNCTIONS_PCT="0"
            fi
            
            echo "lines_pct=$LINES_PCT" >> $GITHUB_OUTPUT
            echo "functions_pct=$FUNCTIONS_PCT" >> $GITHUB_OUTPUT
            echo "lines_hit=$LINES_HIT" >> $GITHUB_OUTPUT
            echo "lines_total=$LINES_TOTAL" >> $GITHUB_OUTPUT
          else
            echo "lines_pct=0" >> $GITHUB_OUTPUT
            echo "functions_pct=0" >> $GITHUB_OUTPUT
          fi
          
      - name: PR Coverage Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Get coverage data - same calculation as badges
            const linesPct = '${{ steps.coverage_report.outputs.lines_pct }}';
            const functionsPct = '${{ steps.coverage_report.outputs.functions_pct }}';
            const linesHit = '${{ steps.coverage_report.outputs.lines_hit }}';
            const linesTotal = '${{ steps.coverage_report.outputs.lines_total }}';
            
            // Create comment body
            const comment = `## üìä Test Coverage Report
            
            | Metric | Coverage | Details |
            |--------|----------|---------|
            | **Lines** | ${linesPct}% | ${linesHit} / ${linesTotal} |
            | **Functions** | ${functionsPct}% | - |
            
            _Coverage report generated from merge of SQLite and Mock DB test runs_`;
            
            // Try to find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Test Coverage Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Upload merged coverage
        uses: actions/upload-artifact@v4
        with:
          name: merged-coverage
          path: merged-coverage/